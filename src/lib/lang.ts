// language features so we can create reactive versions easily
export const add = (a: number, b: number) => a + b;
export const sub = (a: number, b: number) => a - b;
export const div = (a: number, b: number) => a / b;
export const mul = (a: number, b: number) => a * b;
export const mod = (a: number, b: number) => a % b;
export const exp = (a: number, b: number) => a ** b;
export const negate = (a: number) => -a;
export const leftshift = (a: number, b: number) => a << b;
export const rightShift = (a: number, b: number) => a >> b;
export const unsignedRightShift = (a: number, b: number) => a >>> b;
export const bitwiseAnd = (a: number, b: number) => a & b;
export const bitwiseXor = (a: number, b: number) => a ^ b;
export const bitwiseOr = (a: number, b: number) => a | b;
export const logicalAnd = (a: number, b: number) => a && b;
export const logicalOr = (a: number, b: number) => a || b;
export const logicalNot = (a: number) => !a;
export const nullish = (a: number, b: number) => a ?? b;
export const is = (a: any, b: any) => a == b;
export const eq = (a: any, b: any) => a === b;
export const not = (a: any, b: any) => a != b;
export const neq = (a: any, b: any) => a !== b;
export const getTypeof = (a: any) => typeof a;
export const isInstanceof = (a: any, b: any) => a instanceof b;
export const ifElse = (condition: boolean, trueValue?: any, falseValue?: any) => (condition ? trueValue : falseValue);
export const hasItem = <T extends object | Array<any>>(obj: T, key: keyof T) => (key in obj);
export const getItem = <T extends object | Array<any>>(obj: T, key: keyof T) => obj[key];
export const setItem = <T extends object | Array<any>, K extends keyof T>(obj: T, key: K, val: T[K]) => obj[key] = val;
export const deleteItem = <T extends object>(obj: T, key: keyof T) => delete obj[key];
